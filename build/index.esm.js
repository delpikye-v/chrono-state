import{schedule as t,createScope as n,createIntentBus as e,batch as r}from"intentx-core-z";export{createScope}from"intentx-core-z";import*as o from"react";import l,{startTransition as c}from"react";const u={activeEffect:null};function i(n){let e=n;const r=new Set,o=new Set,l=()=>(u.activeEffect&&o.add(u.activeEffect),e);return l.set=(n,l="normal")=>{Object.is(n,e)||(e=n,o.forEach(n=>t(n,l)),r.forEach(n=>t(n,l)))},l.subscribe=t=>(r.add(t),()=>r.delete(t)),l}function s(n){let e,r=!0;const o=new Set,l=()=>{r||(r=!0,o.forEach(n=>t(n)))};return()=>{if(u.activeEffect&&o.add(u.activeEffect),r){const t=u.activeEffect;u.activeEffect=l,e=n(),r=!1,u.activeEffect=t}return e}}function a(n){const e=i(null);let r=null,o=null;const l=()=>(r||(o=new AbortController,r=n(o.signal).then(t=>((null==o?void 0:o.signal.aborted)||e.set(t),t)).finally(()=>{r=null})),r),c=()=>{null==o||o.abort(),o=null,r=null},u=()=>{const t=e();if(null===t)throw l();return t};return u.set=e.set,u.load=l,u.cancel=c,u.invalidate=(n="normal")=>{c(),t(()=>{try{l()}catch{}},n)},u}function f(n,e="normal"){const r=i(void 0);let o=null,l=null,c=null;const u=()=>(o||(l=new AbortController,c=null,o=n(l.signal).then(t=>((null==l?void 0:l.signal.aborted)||r.set(t,e),t)).catch(t=>{throw(null==l?void 0:l.signal.aborted)||(c=t),t}).finally(()=>{o=null})),o),s=()=>{const t=r();if(c)throw c;if(void 0===t)throw u();return t};return s.invalidate=(n=e)=>{null==l||l.abort(),l=null,o=null,t(()=>{try{u()}catch{}},n)},s}function d(n,e="normal"){let r=null,o=!1;const l=()=>{if(!o){null==r||r();try{u.activeEffect=l;const t=n();"function"==typeof t&&(r=t)}finally{u.activeEffect=null}}};return t(l,e),()=>{o=!0,null==r||r(),r=null}}function b(t,n,e="normal"){return d(()=>{n(t())},e)}function v(t,n=Object.is){let e,r=!1;return o=>{const l=t(o);return r&&n(e,l)?e:(r=!0,e=l,l)}}function m(t,n,e,r){var o;const l=null!==(o=null==r?void 0:r.isEqual)&&void 0!==o?o:Object.is;let c;return d(()=>{const o=n(t());void 0!==c&&l(c,o)||(c=o,((null==r?void 0:r.immediate)||void 0!==c)&&e(o))})}const E=n("default");function h(t,n=E){let r=t;const o=new Set,l=e((t,n)=>{const e=new AbortController;return{payload:t,scope:n,state:r,signal:e.signal,setState(t){t(r),o.forEach(t=>t())},emit:(t,e)=>l.emit(t,e,n)}});return{scope:n,state:()=>r,setState(t){t(r),o.forEach(t=>t())},subscribe:t=>(o.add(t),()=>o.delete(t)),emit:(t,e)=>l.emit(t,e,n),on:(t,e)=>l.on(t,e,n),watch:(t,n,e)=>function(t,n,e,r,o=Object.is){const l=v(e,o);let c=!1;const u=()=>{c||r(l(t()))};u();const i=n(u);return()=>{c=!0,i()}}(()=>r,t=>(o.add(t),()=>o.delete(t)),t,n,e)}}function S(t){const n=new Map;return e=>{let r=n.get(e);return r||(r=t(e),n.set(e,r)),r}}function w(t){return o.useSyncExternalStore(n=>{let e=t();return d(()=>{const r=t();Object.is(e,r)||(e=r,n())})},t,t)}function y(t,n,e=Object.is){const r=o.useRef(null),l=()=>{const o=n(t()),l=r.current;return null!==l&&e(l,o)?l:(r.current=o,o)};return o.useSyncExternalStore(n=>d(()=>{t(),n()}),l,l)}function p(){return r}function g(t){return w(o.useMemo(()=>s(t),[t]))}function x(t,n="normal"){o.useEffect(()=>{const e=d(t,n);return()=>e()},[t,n])}function j(t,n){return w(t(n))}function O(t){return l.useSyncExternalStore(t.subscribe,t.state,t.state)}function C(t,n,e=Object.is){const r=o.useMemo(()=>v(n,e),[n,e]),l=o.useCallback(()=>r(t.state()),[t,r]);return o.useSyncExternalStore(t.subscribe,l,l)}function A(t,n){o.useEffect(()=>{const e=b(t,n);return()=>null==e?void 0:e()},[t,n])}function M(t,n="normal"){"low"===n?c(t):t()}export{a as asyncAtom,f as asyncComputed,i as atom,s as computed,v as createSelector,h as createStore,d as effect,S as factoryAtom,M as scheduleReactJob,m as selectAtom,w as useAtom,y as useAtomSelector,p as useBatch,g as useComputed,x as useEffectReact,j as useFactoryAtom,O as useStore,C as useStoreSelector,A as useWatch,b as watch};
