import{schedule as t,createScope as n,createIntentBus as e,batch as r}from"intentx-core-z";export{createScope,batch as transaction}from"intentx-core-z";import*as c from"react";import o,{startTransition as u}from"react";const l={activeEffect:null};function f(n){let e=n;const r=new Set,c=new Set,o=()=>(l.activeEffect&&c.add(l.activeEffect),e);return o.set=(n,o="normal")=>{Object.is(n,e)||(e=n,c.forEach(n=>t(n,o)),r.forEach(t=>t()))},o.subscribe=t=>(r.add(t),()=>r.delete(t)),o}function i(n){let e,r=!0;const c=new Set,o=()=>{r||(r=!0,c.forEach(n=>t(n)))};return()=>{if(l.activeEffect&&c.add(l.activeEffect),r){const t=l.activeEffect;l.activeEffect=o,e=n(),r=!1,l.activeEffect=t}return e}}function s(n){const e=f(null);let r=null,c=!1;const o=()=>(r||(c=!1,r=n().then(t=>(c||e.set(t),t)).finally(()=>{r=null})),r),u=()=>{c=!0,r=null},l=()=>{const t=e();if(null===t)throw o();return t};return l.set=e.set,l.load=o,l.cancel=u,l.invalidate=(n="normal")=>{u(),t(()=>{try{o()}catch{}},n)},l}function a(n,e="normal"){const r=f(void 0);let c=null,o=!1,u=null;const l=()=>(c||(o=!1,u=null,c=n().then(t=>(o||r.set(t,e),t)).catch(t=>{throw o||(u=t),t}).finally(()=>{c=null})),c),i=()=>{const t=r();if(u)throw u;if(void 0===t)throw l();return t};return i.invalidate=(n=e)=>{o=!0,c=null,t(()=>{try{l()}catch{}},n)},i}function E(n,e="normal"){let r=null,c=!1;const o=()=>{if(!c){null==r||r();try{l.activeEffect=o;const t=n();"function"==typeof t&&(r=t)}finally{l.activeEffect=null}}};return t(o,e),()=>{c=!0,null==r||r(),r=null}}function h(t,n,e="normal"){return E(()=>{n(t())},e)}const d=n("default");function m(t,n=d){let r=t;const c=new Set,o=e((t,n)=>{const e=new AbortController;return{payload:t,scope:n,state:r,signal:e.signal,setState(t){t(r),c.forEach(t=>t())},emit:(t,e)=>o.emit(t,e,n)}});return{scope:n,state:()=>r,setState(t){t(r),c.forEach(t=>t())},subscribe:t=>(c.add(t),()=>c.delete(t)),emit:(t,e)=>o.emit(t,e,n),on:(t,e)=>o.on(t,e,n)}}function v(t,n=Object.is){let e,r=!1;return c=>{const o=t(c);return r&&n(e,o)?e:(r=!0,e=o,o)}}function b(t){const n=new Map;return e=>{let r=n.get(e);return r||(r=t(e),n.set(e,r)),r}}function S(){let t=[];return{schedule(n){t.push(n)},flushEffects(){for(;t.length;)t.shift()()}}}function p(t){return c.useSyncExternalStore(n=>{let e=t();return E(()=>{const r=t();Object.is(e,r)||(e=r,n())})},t,t)}function w(t){return p(c.useMemo(()=>i(t),[t]))}function y(t,n){return p(t(n))}function x(t){return o.useSyncExternalStore(t.subscribe,t.state,t.state)}function g(t,n,e=Object.is){const r=o.useRef(null),c=()=>{const c=n(t.state()),o=r.current;return null!==o&&e(o,c)?o:(r.current=c,c)};return o.useSyncExternalStore(t.subscribe,c,c)}function j(t,n){c.useEffect(()=>{const e=h(t,n);return()=>null==e?void 0:e()},[t,n])}function O(t,n="normal"){c.useEffect(()=>{const e=E(t,n);return()=>e()},[t,n])}function z(){return r}function M(t,n="normal"){"low"===n?u(t):t()}export{s as asyncAtom,a as asyncComputed,f as atom,i as computed,v as createSelector,m as createStore,S as createTestRuntime,d as defaultScope,E as effect,b as factoryAtom,M as scheduleReactJob,p as useAtom,z as useBatch,w as useComputed,O as useEffectReact,y as useFactoryAtom,x as useStore,g as useStoreSelector,j as useWatch,h as watch};
